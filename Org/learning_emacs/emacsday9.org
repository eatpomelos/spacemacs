* emacsday9
** Macro and Use-package
#+BEGIN_SRC emacs-lisp
  (setq my-var 1)
  (setq my-var (+ 1 my-var))

  (defmacro inc (var)
    (list 'setq var (list '1+ var)))

  (inc my-var)

  (macroexpand '(inc my-var))

#+END_SRC

#+RESULTS:
: inc

- 宏和函数的区别
- 函数会先执行参数再传给函数，函数返回的是一个值
- 宏会直接把表达式直接传递过去，宏返回的是一个表达式，但是这个表达式会
  立刻被执行

#+BEGIN_SRC  emacs-lisp
  (defun my-print (number)
    (message "This is a number:%d") number)

  (my-print 2)
  (my-print (+2 3))

  (quote (+1 3))
  ;; return a list

  (defmacro my-print-2 (number)
    `(message "This is a number:%d" ,number))

  (my-print-2 2)
  (my-print-2 (+ 4 3))

  (defmacro inc (var)
    (list 'setq var (list '1+ var))
    (setq my-var 2)
    (inc my-var)

    (defmacro inc2 (var1 var2)
      (list 'progn (list 'inc var1) (list 'inc var2)))

    (macroexpand-all '(inc2 my-var my-var)))
#+END_SRC
- quote 和单引号是一样的，会将后面的东西当作是一个名字而不是直接求值
- macroexpand 是将宏展开
- pp可以打印后面的宏展开
** use-package 
#+BEGIN_SRC emacs-lisp
  (use-package xxxx)
   (pp (macroexpand '(use-package xxxxx)))
#+END_SRC
- 使用use-package可以让emacs启动的时候，如果某个包不存在也不会直接启动失败，而是会报一个警
  告
- 可以加快emacs启动速度

- 下面是使用use-package的例子，但是这里暂时不加入到配置文件中去
#+BEGIN_SRC emacs-lisp
  (use-package color-moccur
    :commands (isearch-moccur isearch-all)
    :bind (("M-s O" . moccur)
	   :map isearch-mode-map
	   ("M-o" . isearch-moccur)
	   ("M-O" . isearch-moccur-all))
    :init
    (setq isearch-lazy-highlight t)
    :config
    (use-package moccur-edit))
#+END_SRC


- 头脑风暴代码(可能现在看不懂)
#+BEGIN_SRC emacs-lisp
  (defmacro defsynonym (old-name new-name)
    `(defmacro,new-name (&rest args)
       `(,',old-name,@args)))``
#+END_SRC

more discussion:https://emacs-china.org/t/lisp/357

Readme more about macro:https://www.gnu.org/software/emacs/manual/html_node/elisp/Macros.html#Macros

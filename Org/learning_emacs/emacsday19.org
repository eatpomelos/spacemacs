* emacsday19
由于没有将.emacs.d里面的文件纳入版本控制，所以在需要某些配置的时候，不再那边更改，直接在.spacemacs.d下的init.el里面进行更改
** COMMENT elisp的一些hack技巧
hooks
在某一个模式启动的时候运行一些代码
#+begin_src emacs-lisp
(defun my-org-hook)
(add-hook 'org-mode-hook 'my-org-hook)
#+end_src

*** 下面是视频中解决一些问题的elisp代码
子龙大神写的一个函数
#+begin_src emacs-lisp
    ;; 子龙大佬写的一个实例代码，这里作为参考
  (defun my-ranger ()
    (intertactive)
    (if golden-ratio-mode
        (progn
          (golden-ratio-mode -1)
          (ranger)
          (setq golden-ration-previous-enable t))
      (progn
        (ranger)
        (setq golden-ration-previous-enable nil))))

  (defun my-quit-ranger ()
    (interactive)
    (if golden-ration-previous-enable
        (progn
          (ranger-close)
          (golden-ratio-mode 1))
      (ranger-close)))

  (with-eval-after-load 'ranger
    (progn
      (define-key ranger-normal-mode-map (kbd "q") 'my-quit-ranger)
      ))
  (spacemacs/set-leader-keys "ar" 'my-ranger)
#+end_src
论坛中解决分屏的一个方案
#+begin_src emacs-lisp
  (defun split-window-left/right->up/down ()
      "把左右两屏调整为上下两屏.
    A
    A|B => -
    B"
      (interactive)
      (let ((buf (current-buffer)))
        ;;选中左边window
        （select-window (frame-first-window))
        ;;删除右侧window
        (delete-other-windows)
        ;;分屏、选中下边window
        (select-window (split-window-below))
        ;;切换至最近buffer
        (switch-to-buffer (other-buffer))
        ;;选中原来buffer所在的window
        (select-window (get-buffer-window buf)))
#+end_src
解决左右分屏
#+begin_src emacs-lisp
  (defadvice org-open-at-point (after my-org-open-at-point activate)
    (while (> (count-windows) 2)
      (delete-window (cadr (window-list-1)))))
#+end_src
- 按下shift-alt ：可以运行函数 eval-expression
分屏以后下面的信息显示不完整
按下shift-alt ：运行(window-width)可以现实当前窗口的宽度

- 写一个函数来实现简便地替换字符串
#+begin_src emacs-lisp
  (defun pomelo/evil-quick-replace (beg end)
    (interactive "r")
    (while (evil-visual-state-p)
      (evil-exit-visual-state)
      (let ((selection (regexp-quote (buffer-substring-no-properties beg end))))
        (setq command-string (format "%%s /%s//g" selection))
        (minibuffer-with-setup-hook
            ()))))
#+end_src
在(interactive "r")这里面的r表示的是region，这个会接收两个参数，分别是当前选中区域的开头和结尾
这里函数的运行过程是，如果是visual buffer那么就将beg和end选中成为一个region，并且启动evil-ex，在里面填充字符串command-strng
在此之后将光标向后移动两个字符
后面有一个字符打不出来，这里代码是不完整的

*** Advice
- 可以在不修改一个函数的前提下，让这个函数在执行之前、执行之后、执行过程中调用一些额外的代码
#+begin_src emacs-lisp
    (defun bar (x)
      (message "in bar")
      (+ x 1))

  (bar 1)
    ;; 运行结果是2
    (defadvice bar (before my-bar-hack activate)
      (message "before bar"))
    (bar 2)
    ;; 运行结果是 before bar 然后再是2,也就是说在执行bar之前会执行我们自己定义的函数的功能
    (ad-deactivate 'bar)
    ;;在执行完成上面的语句之后再执行bar函数就不会执行我们自己定义的那句message语句了
    (ad-activate 'bar)
    ;; 执行完上面的语句之后又会执行我们自己定义的语句
    (defadvice bar (after my-bar-hack-2 activate)
      (message "after bar"))

  (bar 3)

  ;; around 可以在函数执行的过程中执行一个动作
  ;; small example在执行一个函数的过程中会先执行around定义的功能，注意这里和before的区分
  (defun foo (x)
    (* 2 x))

  (defadvice foo (around bar activate)
    (setq ad-return-value
          (if (= x 1)
              42
            (+1 ad-do-it))))

  (foo 2)
#+end_src
这个特性是很有用的，当我们在执行某一个命令的时候，我们可能需要在这个命令执行之前或者之后，绑定某一个动作，这个时候这个特性就很有用了

*** 调试elisp
- 可以在elisp函数中加入一个debug语句，执行时会进入debug模式
当处于debug模式的时候:
c 退出当前的debug中断，继续执行直到遇到下一个error或debug点时才再次进入debug模式
d 单步执行，会进入函数内部;
e 求值，结果将会显示在minibuffer里;
R 与上面的e命令一样，不过它会将求值结果保存在"Debugger-record"这个buffer里;
q 退出debug，程序交由最上层的emacs接管

这里是一个简单的实例
#+begin_src emacs-lisp
  (defun demo()
    "debug demo function"
    (interactive)
    (let ((a "a")
          (b "value b")
          (c 1))
      (debug)
      (message "middle")
      (setq c (+ 1 c))
      (xyz "a")
      (message "999")
      ))
#+end_src

- 另外一种是使用edebug-defnu来进行调试，但是这里似乎有点问题

*** 如何编写自己的minor-mode 
#+begin_src emacs-lisp
  (defun insert-foo ()
    (interactive)
    (insert "foo"))

  ;; 下面的keymap定义在自己的minor-mode下的自己的快捷键
  (define-minor-mode
    shadowsocks-proxy-mode
    :global t
    :init-value nil
    :lighter " SS"
    :keymap (let ((map (make-sparse-keymap)))
              (define-key map (kbd "C-c f") 'insert-foo))
    (if shadowsocks-proxy-mode
        (setq url-gateway-method 'socks)
      (setq url-gateway-method 'native)))

    (define-global-minor-mode
      global-shadowsocks-proxy-mode shadowsocks-proxy-mode shadowsocks-proxy-mode
      :group 'shadowsocks-proxy)


  ;; 下面的代码是演示一些比较简单的功能，这里就是要展示一些基础的功能
  (defun my-tes ()
    "test a programe"
    (interactive)
    (setq lov 4)
    (message "before %s" lov))

  (my-tes)
#+end_src
- 要想掌握这个功能要好好看一下下面的博客：how to make an emacs minor mode
*** 视频中的一些网址
Ranger与golden ratio不兼容
https://emacs-china.org/t/ranger-golden-ratio/964
如何快速把左右两屏调整为上下两屏
https://emacs-china.org/t/topic/945/2
多个窗口spaceline显示不全
https://emacs-china.org/t/spacemacs/389
怎么设置左右分屏最多为两个
https://emacs-china.org/t/topic/889/3
how to make an emacs minor mode
https://nullprogram.com/blog/2013/02/06/
elisp defadvice around clarification
https://stackoverflow.com/questions/21502367/elisp-defadvice-around-clarification
https://ergoemacs.org/emacs/emacs_avoid_lambda_in_hook.html
https://emacs-fu.blogspot.com/2008/12/hooks.html
